// Bag class that implements Iterable interface

CLASS Bag<T> IMPLEMENTS Iterable<T>
    // Declare private attributes
    DECLARE PRIVATE Node<T> head
    DECLARE PRIVATE int numItems

    // Getter method for numItems
    METHOD int getNumItems()
        RETURN numItems
    END METHOD

    // Getter method for head
    METHOD T getHead()
        RETURN head
    END METHOD

    // Method to check if Bag is empty
    METHOD boolean isEmpty()
        // Return boolean value based on the number of items
        RETURN numItems EQUALS 0
    END METHOD

    // Method to add item to Bag
    METHOD add(T item)
        // Check if item to add is null
        IF (item EQUALS NULL)
            THROW EXCEPTION IllegalArgumentException WITH MESSAGE "Item to add cannot be null."
        END IF

        // Store head to tempNode
        DECLARE Node<T> tempNode = head
    
        // Create a new empty node to be stored as the head
        head = NEW Node<T>(item)

        // Set the nextItem to be the original firstNode
        CALL head.setNextItem(tempNode)

	// Increment numItems
        INCREMENT numItems
    END Method

    // Method to remove item from Bag
    METHOD remove(T item)
        // Check if item to remove is null
        IF (item EQUALS NULL)
            THROW EXCEPTION IllegalArgumentException WITH MESSAGE "Item to remove cannot be null."
        END IF

        // Create temporary node and set it equal to the head
        DECLARE Node<T> currentItem = head;
    
        // Check if bag is empty
        IF (CALL isEmpty())
            RETURN
        END IF

        // Handle situation if the head is the item to be removed
        IF (CALL head.getItem() EQUALS item)
            head = CALL head.getNextItem()
            DECREMENT numItems
            RETURN
        END IF

        // Traverse through the linked list
        WHILE (CALL currentItem.getNextItem() NOT EQUALS NULL)

            // Check if item matches currentItem's next item
            IF (CALL currentItem.getNextItem() EQUALS item)

                // Remove the currentItem's next item
		CALL currentItem.setNextItem(CALL currentItem.getNextItem().getNextItem())

                // Decrement the numItems and return
                DECREMENT numItems
                RETURN
            END IF
   
            // No item was removed, continue through the linked list
            currentItem = CALL currentItem.getNextItem()
        END WHILE
    END METHOD    
    
    // Method to check if bag contains item
    METHOD boolean contains(T item)
        // Check if item to search for is null
        IF (item EQUALS NULL)
            THROW EXCEPTION IllegalArgumentException WITH MESSAGE "Item to search for cannot be null."
        END IF

        // Create temporary node and set it equal to the head
        DECLARE Node<T> currentItem = head

        // Traverse through list to check if it contains item
        WHILE (currentItem NOT EQUALS NULL)
            
            // Check if currentItem equals the item being searched for
            IF (CALL currentitem.getItem() EQUALS item)
                RETURN TRUE
            END IF

            // No match, continue through the linked list
            currentItem = CALL currentItem.getNextItem()
        END WHILE
    
        // Return false to indicate no match in the linked list
        RETURN FALSE
    END METHOD

    // Method to return number of occurrences for given item
    METHOD int count(T item)
	// Check if item to count occurrences of is null
        IF (item EQUALS NULL)
            THROW EXCEPTION IllegalArgumentException WITH MESSAGE "Item to count occurrences of cannot be null."
        END IF

        // Declare and initialize occurrences variable
        DECLARE int occurrences = 0

        // Create temporary node and set it equal to the head
        DECLARE Node<T> currentItem = head

        // Traverse through list to check if it contains item
        WHILE (currentItem NOT EQUALS NULL)

            // Check if currentItem equals the item being searched for
            IF (CALL currentItem.getItem() EQUALS item)
                
                // Increment occurrences
                INCREMENT occurrences
            END IF

            // No match, continue through the linked list
            currentItem = CALL currentItem.getNextItem()

        END WHILE

        // Return total occurrences of item
        RETURN occurrences
    END METHOD

    // Method to count number of items in the Bag
    METHOD int size()
        // Declare and initialize size variable to 0
        DECLARE int bagSize = 0

        // Create temporary node and set it equal to the head
        DECLARE Node<T> currentItem = head

        // Traverse through list to keep count of total items in bag
        WHILE (currentItem NOT EQUALS NULL)
            // Increment bag size by one
            INCREMENT bagSize
    
            // Continue to next item in Bag
            currentItem = CALL currentItem.getNextItem()
        END WHILE

        // Return the size of the bag
        RETURN bagSize
    END METHOD

    // Method to merge two bags
    METHOD merge(Bag<T> otherBag)
        // Check if otherBag is null
        IF (otherBag EQUALS NULL)
            THROW EXCEPTION IllegalArgumentException WITH MESSAGE "Cannot merge with a Bag that is null."
        END IF
      
        // Create temporary node and set it equal to the head of otherBag
        DECLARE Node<T> currentItem = CALL otherBag.getHead()

        // Traverse through otherBag and add each item to this Bag
        WHILE (currentItem NOT EQUALS NULL)
            // Add item from otherBag to this Bag
            CALL THIS.add(CALL currentItem.getItem())

            // Continue to next item in otherBag
            currentItem = CALL currentItem.getNextItem()
        END WHILE
    END METHOD

    // Method to return new bag with distinct items
    METHOD Bag<T> distinct()
        // Create temporary node and set it equal to the head
        DECLARE Node<T> currentItem = head

        // Create new Bag object to store distinct values
        DECLARE Bag<T> distinctBag = NEW Bag<T>()
        
        // Traverse through list and add distinct values to distinctBag
        WHILE (currentItem NOT EQUALS NULL)
            // Check if currentItem is already in distinctBag, if not add it
            IF (NOT CALL distinctBag.contains(CALL currentItem.getItem()))
                CALL distinctBag.add(CALL currentItem.getItem())
            END IF
            
            // Continue to next item in original Bag
            currentItem = CALL currentItem.getNextItem()
        END WHILE

        // Return new bag of distinct items
        RETURN distinctBag
    END METHOD

    // Override iterator method
    OVERRIDE METHOD Iterator<T> iterator()
        // Return new BagIterator starting at the head
        RETURN NEW BagIterator(head)
    END METHOD

    // Inner class to create BagIterator
    INNER CLASS BagIterator IMPLEMENTS Iterator<T>
        
        // Declare private attribute
        DECLARE PRIVATE Node<T> currentItem

        // Parameterized constructor
        CONSTRUCTOR BagIterator(Node<T> head)      
            // Set currentItem to head of linked list
            currentItem = head
        END CONSTRUCTOR

        // Override hasNext method
        OVERRIDE METHOD Boolean hasNext()
            // Check if currentItem is the tail
            RETURN currentItem NOT EQUALS NULL
        END METHOD

        // Override next method
        OVERRIDE METHOD T next()
            // Check if there is next item
            IF (NOT CALL hasNext())
                // If no next item, throw exception
                THROW EXCEPTION NoSuchElementException WITH MESSAGE "There are no more items left."
            END IF

            // Store current item to temporary variable
            DECLARE T returnItem = CALL currentItem.getItem()
            
            // Set currentItem to the next item of the linked list
            currentItem = CALL currentItem.getNextItem()

            // Return the item that was stored in temporary variable
            RETURN returnItem
        END METHOD
    END CLASS
END CLASS


// Node class
CLASS Node<T>

    // Declare private attributes
    DECLARE PRIVATE T item
    DECALRE PRIVATE Node<T> nextItem

    // Parameterized constructor
    CONSTRUCTOR Node(T item)
        THIS.item = item
        THIS.nextItem = NULL
    END CONSTRUCTOR

    // Getter method for item
    METHOD T getItem()
        RETURN THIS.item
    END METHOD
 
    // Getter method for nextItem
    METHOD Node<T> getNextItem()
        RETURN nextItem
    END METHOD

    // Setter method for nextItem
    METHOD setNextItem(Node<T> nextItem)
        THIS.nextItem = nextItem
    END METHOD
END CLASS


// Main class
CLASS Main
    MAIN METHOD
        // Create two instances of the "Bag" class
        DECLARE Bag<Integer> testBag1 = NEW Bag<Integer>()
        DECLARE Bag<Integer> testBag2 = NEW Bag<Integer>()
        
        // Add items to testBag1, including duplicates
        CALL testBag.add(10)
        CALL testBag.add(20)
        CALL testBag.add(10)
        CALL testBag.add(40)

        // Add items to testBag2, including duplicates
        CALL testBag.add(5)
        CALL testBag.add(20)
        CALL testBag.add(20)

        // Print the size of each bag using the "size" method
        OUTPUT "The size of testBag1 is: " + CALL testBag1.size() + NEWLINE
        OUTPUT "The size of testBag2 is: " + CALL testBag2.size() + NEWLINE

        // Merge the two bags together using the "merge" method
        CALL testBag1.merge(testBag2)

        // Print the merged bag contents
        OUTPUT "Items of the merged bag: "
        FOR each item IN testbag
            OUTPUT item + " "
        END FOR
        OUTPUT NEWLINE

        // Create a new bag containing only the distinct elements using the "distinct" method
        DECLARE Bag<Integer> distinctBag = CALL testBag1.distinct()

        // Print the distinct bag contents
        OUTPUT "Items of the distinct bag: "
        FOR each item IN distinctBag
            OUTPUT item + " "
        END FOR
        OUTPUT NEWLINE
    END METHOD
END CLASS